----------------------------------------------------------------
    Виды Retention:

@Retention позволяет указать жизненный цикл аннотации:
Будет ли она только в исходном коде (SOURCE)
В скомпилированном файле (CLASS{java}/BINARY{kotlin})
Видна в процессе выполнения (RUNTIME)
----------------------------------------------------------------
    Граф зависимостей:

Совокупность всех объектов, которые умеет создавать компонент
- это граф объектов компонента или граф зависимостей компонента.
----------------------------------------------------------------
    Показать работу скоупа

Activity1 и Activity2 - FirstActivitiesScope
Activity3 - SecondActivitiesScope
----------------------------------------------------------------
    Как работают generated-классы (разобраться с внутренностями)

Сгенерированный класс реализует интерфейс написанного компонента.
Хранит в себе все доступные провайдеры (соответственно построенному графу зависимостей);
inject() - это get(). В inject передаётся instance для заполнения зависимостями;
Внешние зависимости компонента - static (вроде как)
----------------------------------------------------------------
    Добавить квалификаторы (2 способа описания)

Первый способ - @Named по умолчанию со строкой в качестве аргумента
Второй способ - переопределённый @Named с произвольным аргументом
----------------------------------------------------------------
    Subcomponents

В отдельном модуле
----------------------------------------------------------------
    Можно ли управлять жизненным циклом компонента через Scope?

Scope влияет только на то, как будут работать аннотированные провайдеры
- как фабрика или как синглтон (в пределах компонента, который определяет эти провайдеры).
Жизненный цикл компонента полностью на совести разработчика.
----------------------------------------------------------------